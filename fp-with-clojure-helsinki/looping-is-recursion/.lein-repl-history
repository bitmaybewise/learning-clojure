(use 'looping-is-recursion :reload)
(power 2 2)
(use 'looping-is-recursion :reload)
(power 2 2)
quit
(use 'looping-is-recursion :reload)
(power 2 2)
(power 2 0)
(power 2 1)
(power 0 2)
(power 1 2)
(power 2 2)
(use 'looping-is-recursion :reload)
(power 2 2)
(+ 2 (* 2 2))
(+ 2 (* 2.0 2.0))
(+ 2 (* 2 2.0))
(+ 2 (* 2 2))
(+ 2.0 (* 2 2))
quit
(use 'looping-is-recursion :reload)
(power 2 2)
(use 'looping-is-recursion :reload)
(power 2 2)
(dec 100)
(power 2 2)
(use 'looping-is-recursion :reload)
(power 2 2)
(* 2 2)
(use 'looping-is-recursion :reload)
(* 2 2)
(power 2 2)
(defn f [a b acc])
(defn f [a b acc] )
(defn f [a b acc]
  (cond
    (= base 0) 0
    (= exp 0) acc
(defn f [a b acc]
  (cond
    (= a 0) 0
    (= b 0) acc
    :else (recur a (dec b) (* acc a)))
)
(f 0 10)
(f 0 10 1)
(f 7 0 1)
(f 7 0 10)
(f 2 2 10)
(f 2 2 1)
(use 'looping-is-recursion :reload)
(power 2 2)
(power 2 3)
(use 'looping-is-recursion :reload)
(last-element [])
(last-element [1])
(last-element [1 2 3])
(empty? xs)
(empty? nil)
(use 'looping-is-recursion :reload)
(last-element [1 2 3])
(use 'looping-is-recursion :reload)
(seq= [] [])
(seq= [1] [])
(seq= [1] [1])
(seq= [1] [1 2])
(seq= [1 2] [1 2])
(seq= [1 2 4] [1 2])
(seq= [1 2 4] [1 2 4])
(seq= [1 2 4] [])
(seq= [] [1 2 3])
(seq= [] [])
(seq= '() [])
(seq= '(1 2) [])
(seq= '(1 2) [1 2])
(seq= [1 2 4] '(1 2 4))
(seq= [1 2 3] [1 2 3 4])
(seq= [1 3 5] [])
(ctest/is (= (seq= [1 2 4] '(1 2 4))) true)
(:require [clojure.test :as ctest])
(require [clojure.test :as ctest])
(acc 10)
(plus 10)
(add 10)
(inc 10)
(use 'looping-is-recursion :reload)
(find-first-index zero? [])
(find-first-index zero? [0 1 2 3])
(find-first-index zero? [1 2 0 3])
(find-first-index zero? [1 2 0])
(find-first-index zero? [1 2 3])
(when true (1))
(when (true) (1))
(when 'true (1))
(defn [x]
  (when [seq x]
    (println x)))
(defn [x]
  (when (seq x)
    (println "foi")))
(defn bla [x]
  (when (seq x)
    (println "foi")))
bla []
bla [1]
bla nil
(bla [])
(bla [1])
(use 'looping-is-recursion :reload)
(find-first-index zero? [1 2 3])
(use 'looping-is-recursion :reload)
(avg [])
(avg [1 2 3])
(apply + [1 2 3])
(/ (apply + [1 2 3]) (count [1 2 3]))
(use 'looping-is-recursion :reload)
(avg [1 2 3])
(avg [1 2 3 4 5 6])
(toggle #{1 2 3} 1)
(use 'looping-is-recursion :reload)
(parity [:a :b :c])
(use 'looping-is-recursion :reload)
(parity [:a :b :c])
(use 'looping-is-recursion :reload)
(parity [:a :b :c])
(use 'looping-is-recursion :reload)
(parity [:a :b :c])
(parity [:a :b :c :a])
(use 'looping-is-recursion :reload)
(fast-fibo 1)
(fast-fibo 0)
(fast-fibo 2)
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(fast-fibo 3)
(use 'looping-is-recursion :reload)
(fast-fibo 3)
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(use 'looping-is-recursion :reload)
quit
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(seq= [1 2 nil] [1 2])
(seq [])
(seq '())
(use 'looping-is-recursion :reload)
(seq= [1 2 nil] [1 2])
(seq= [1 2 4] '(1 2 4))
(use 'looping-is-recursion :reload)
(seq= [1 2 4] '(1 2 4))
(seq= [1 2 nil] [1 2])
(use 'looping-is-recursion :reload)
(seq= [1 2 nil] [1 2])
(seq= [1 2 4] '(1 2 4))
(use 'looping-is-recursion :reload)
(seq= [1 2 4] '(1 2 4))
(seq= [1 2 nil] [1 2])
(use 'looping-is-recursion :reload)
(seq= [1 2 nil] [1 2])
(use 'looping-is-recursion :reload)
(seq= [1 2 nil] [1 2])
(seq= [1 2 4] '(1 2 4))
(fast-fibo 0)
(fast-fibo 1)
(use 'looping-is-recursion :reload)
(fast-fibo 1)
(fast-fibo 2)
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(fast-fibo 3)
(fast-fibo 4)
(fast-fibo 5)
(fast-fibo 0)
(fast-fibo 1)
(fast-fibo 2)
(fast-fibo 3)
(fast-fibo 4)
(fast-fibo 5)
(use 'looping-is-recursion :reload)
(fast-fibo 3)
(fast-fibo 1)
(fast-fibo 2)
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(fast-fibo 0)
(fast-fibo 1)
(fast-fibo 2)
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(fast-fibo 3)
(fast-fibo 4)
(fast-fibo 5)
(fast-fibo 3)
(use 'looping-is-recursion :reload)
(fast-fibo 3)
(fast-fibo 2)
(fast-fibo 3)
(use 'looping-is-recursion :reload)
(fast-fibo 3)
(use 'looping-is-recursion :reload)
(fast-fibo 3)
(fast-fibo 2)
(fast-fibo 3)
(fast-fibo 4)
(use 'looping-is-recursion :reload)
(fast-fibo 4)
(fast-fibo 2)
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(use 'looping-is-recursion :reload)
(fast-fibo 2)
(fast-fibo 3)
(use 'looping-is-recursion :reload)
(fast-fibo 3)
(fast-fibo 4)
(fast-fibo 5)
(use 'looping-is-recursion :reload)
(fast-fibo 5)
(fast-fibo 3)
(fast-fibo 2)
(fast-fibo 1)
(fast-fibo 3)
(fast-fibo 4)
(fast-fibo 5)
(use 'looping-is-recursion :reload)
(fast-fibo 5)
(fast-fibo 2)
(fast-fibo 3)
(use 'looping-is-recursion :reload)
(fast-fibo 3)
(fast-fibo 4)
(fast-fibo 5)
(fast-fibo 6)
(fast-fibo 1)
(fast-fibo 2)
(fast-fibo 85)
[:a
]
([:a])
('[:a])
([:a] :a)
([:a] 0)
([:a] 1)
(use 'looping-is-recursion :reload)
(cut-at-repetition [])
(cut-at-repetition [1])
(use 'looping-is-recursion :reload)
(cut-at-repetition [1])
(use 'looping-is-recursion :reload)
(cut-at-repetition [1])
(use 'looping-is-recursion :reload)
(cut-at-repetition [1])
(use 'looping-is-recursion :reload)
(cut-at-repetition [1])
(cut-at-repetition [])
(conj nil [])
(use 'looping-is-recursion :reload)
(conj nil [])
(cut-at-repetition [])
(cut-at-repetition [1])
(use 'looping-is-recursion :reload)
(cut-at-repetition [1])
(cut-at-repetition [1 2])
(cut-at-repetition [1 2 1])
(use 'looping-is-recursion :reload)
(cut-at-repetition [])
(cut-at-repetition [1])
(cut-at-repetition [1 2])
(use 'looping-is-recursion :reload)
(cut-at-repetition [])
(cut-at-repetition [1])
(cut-at-repetition [1 2])
(use 'looping-is-recursion :reload)
(cut-at-repetition [1 2])
(cut-at-repetition [1])
(cut-at-repetition [])
(use 'looping-is-recursion :reload)
(cut-at-repetition [])
(cut-at-repetition [1])
(use 'looping-is-recursion :reload)
(cut-at-repetition [])
(cut-at-repetition [1])
(cut-at-repetition [1 2])
(use 'looping-is-recursion :reload)
(cut-at-repetition [1])
(cut-at-repetition [])
(cut-at-repetition [1])
(conj 1 [])
(conj [1] [])
(conj 1 [])
(conj [] 1)
(use 'looping-is-recursion :reload)
(cut-at-repetition [1])
(cut-at-repetition [])
(cut-at-repetition [1 2])
(use 'looping-is-recursion :reload)
(cut-at-repetition [])
(cut-at-repetition [1])
(cut-at-repetition [1 2])
(cut-at-repetition [1 2 3])
(cut-at-repetition [1 2 3 1])
(cons 1 [])
(cons 1 [2])
(cons 1 [2 3])
(cons 1 [3 2])
(conj [3 2] 1)
(use 'looping-is-recursion :reload)
(cut-at-repetition [1])
(cut-at-repetition [1 2])
(cut-at-repetition [1 2 3])
(cut-at-repetition [1 2 3 1])
quit
