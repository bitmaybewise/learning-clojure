(doc interleave)
(interleave ',' "oi")
(interleave ',')
(interleave '-' "bla")
(interleave "bla" '-')
(interleave "bla" "oi")
(apply str ["hello", "world"])
(apply str (interleave ["hello", "world"] " "))
(use 'one-function-to-rule-them-all :reload)
(str-cat ["oi", "bla"])
(doc interpose)
(interpose " " [1 2])
(use 'one-function-to-rule-them-all :reload)
(str-cat ["oi", "bla"])
(str-cat ["oi" "bla"])
(use 'one-function-to-rule-them-all :reload)
(str-cat ["oi" "bla"])
quit
(doc concat)
(concat 1 2 [])
(concat [1] [2] [])
(use 'one-function-to-rule-them-all :reload)
(my-interpose 0 [1 2])
(use 'one-function-to-rule-them-all :reload)
(my-interpose 0 [1 2])
(use 'one-function-to-rule-them-all :reload)
(my-interpose 0 [1 2])
(doc conj)
(use 'one-function-to-rule-them-all :reload)
(doc conj)
(my-interpose 0 [1 2])
(conj [] 1 2)
(conj [] 1 2 3)
(conj [] nil)
(use 'one-function-to-rule-them-all :reload)
(my-interpose 0 [1 2])
(my-interpose 0 [1])
(my-interpose 0 [1 1 2 3])
(use 'one-function-to-rule-them-all :reload)
(my-count [1])
(use 'one-function-to-rule-them-all :reload)
(my-count [1])
(my-count [])
(my-count [1 2])
(use 'one-function-to-rule-them-all :reload)
(my-count [1 2])
(my-count [1 2 3])
(my-count [])
(use 'one-function-to-rule-them-all :reload)
(my-reverse [])
(my-reverse [1])
(my-reverse [1 2])
(my-reverse [1 2 4])
(my-reverse [1 2 4 5])
(my-reverse [1 2 4 5 6])
(my-reverse [1 2 4 5 6 1])
(my-reverse [1 2 4 5 6 1 2])
quit
(cons 3 '(1 2 4 5))
(conj 3 '(1 2 4 5))
(seq #{1 2 3 4})
(set [1 2 3 4])
(cons 3 (set [1 2 4]))
(conj 3 (set [1 2 4]))
(use 'one-function-to-rule-them-all :reload)
(count-params)
(use 'one-function-to-rule-them-all :reload)
(count-params)
(use 'one-function-to-rule-them-all :reload)
(count-params)
(count-params :a)
(seq x)
(seq 1)
(list 1)
(list [1])
(use 'one-function-to-rule-them-all :reload)
(count-params)
(count-params 1)
(count-params 1 2)
(count-params 1 2 3)
(use 'one-function-to-rule-them-all :reload)
(count-params 1 2 3)
(count-params)
(use 'one-function-to-rule-them-all :reload)
(my-*)
(my-* 1)
(my-* 1 2)
(my-* 1 2 3)
(use 'one-function-to-rule-them-all :reload)
(my-* 1 2 3)
(use 'one-function-to-rule-them-all :reload)
(insert 1 [])
(insert [] 1)
(insert [1] 1)
(insert [1] 2)
(insert [1] 4)
(insert [1 2 3] 4)
(insert [1 2 5 6] 4)
(insert [1 2 5 6] 3)
(insert [1 2 5 6] 3 4)
(insertion-sort [1 2 5 6])
(insertion-sort [1 5 6 2])
(insertion-sort [1 5 6 2 3])
(insertion-sort [1 6 2 3 4])
(use 'one-function-to-rule-them-all :reload)
(insertion-sort [1 6 2 3 4])
(doc range)
(insertion-sort (range -1 10))
(insertion-sort (range (-1) 10))
(insertion-sort (range (- 1) 10))
(insertion-sort (range (- 10) 10))
(use 'one-function-to-rule-them-all :reload)
(insertion-sort (range (- 10) 10))
(use 'one-function-to-rule-them-all :reload)
(filter pre-and [1 2 3])
(filter (pre-and) [1 2 3])
(use 'one-function-to-rule-them-all :reload)
(filter (pre-and) [1 2 3])
(use 'one-function-to-rule-them-all :reload)
(filter (pre-and) [1 2 3])
(filter (pred-and) [1 2 3])
(use 'one-function-to-rule-them-all :reload)
(filter (pred-and) [1 2 3])
(filter (pred-and) (range 10))
(filter (pred-and even?) (range 10))
(use 'one-function-to-rule-them-all :reload)
(filter (pred-and) (range 10))
(use 'one-function-to-rule-them-all :reload)
(filter (pred-and) (range 10))
(filter (pred-and even?) (range 10))
(use 'one-function-to-rule-them-all :reload)
(filter (pred-and even? even?) (range 10))
(filter (pred-and even? odd?) (range 10))
(filter (pred-and even? (fn [x] (= x 2))) (range 10))
(filter (pred-and even? #(= % 2)) (range 10))
(filter (pred-and even? #(> % 2)) (range 10))
(filter (pred-and even? #(> % 2) (< % 8)) (range 10))
(filter (pred-and even? (< % 8)) (range 10))
(filter (pred-and even? #(< % 8)) (range 10))
(filter (pred-and even? #(> % 2) #(< % 8)) (range 10))
(use 'one-function-to-rule-them-all :reload)
(doc and)
(use 'one-function-to-rule-them-all :reload)
(and [true true true])
(apply and [true true true])
(reduce and true [true true true])
(and 1 2 3)
(and true true true)
(and (true true true))
(and '(true true true))
(apply and '(true true true))
quit
(map #(% 0) [number? even?])
(reduce and (map #(% 0) [number? even?]))
(apply and (map #(% 0) [number? even?]))
(reduce and true (map #(% 0) [number? even?]))
(reduce #(and % %2) (map #(% 0) [number? even?]))
(reduce #(and % %2) (map #(% 0) [number? odd?]))
(use 'one-function-to-rule-them-all :reload)
(conj [] 2 3)
(use 'one-function-to-rule-them-all :reload)
(map (pred-and) (range 10) )
(map (pred-and even?) (range 10) )
(map (pred-and even? odd?) (range 10) )
(map (pred-and even? number?) (range 10) )
(map (pred-and number? even?) (range 10) )
(map (pred-and number? even? odd?) (range 10) )
(map (pred-and number? even? #(= (mod % 2) 0)) (range 10) )
quit
(use 'one-function-to-rule-them-all :reload)
(filter (pred-and number? even? #(= (mod % 2) 0)) (range 10) )
(filter (pred-and number? even? #(= (mod % 3) 0)) (range 10) )
(filter (pred-and number? even? #(= (mod % 4) 0)) (range 10) )
(filter (pred-and number? even? #(= (mod % 3) 0)) (range 10) )
(filter (pred-and number? even? #(= (mod % 5) 0)) (range 10) )
(filter (pred-and number? even? #(= (mod % 1) 0)) (range 10) )
(filter (pred-and number? even? #(= (mod % 2) 0)) (range 10) )
(filter (pred-and number? even? #(= (mod % 2) 0)) [2] )
(filter (pred-and number? even? #(= (mod % 2) 0)) [2])
(filter (pred-and number? even? #(= (mod % 2) 0)) [])
(filter (pred-and number? even? #(= (mod % 2) 0)) [1 2])
(filter (pred-and number? even? #(= (mod % 2) 0)) [2])
(filter (pred-and number? even?) [2])
(filter (pred-and even?) [2])
quit
(use 'one-function-to-rule-them-all :reload)
(insertion-sort [] 1)
(insertion-sort [3 2 1])
quit
